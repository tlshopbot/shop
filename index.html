const express = require('express');
const fetch = require('node-fetch');
const { default: fetchCookie } = require('fetch-cookie'); // Измененный импорт
const { CookieJar } = require('tough-cookie');
const cors = require('cors');
const { JSDOM } = require('jsdom');
const natural = require('natural');
const tokenizer = new natural.WordTokenizer();

const customTokenizer = {
    tokenize: function (text) {
        // Регулярное выражение:
        // 1. Составные идентификаторы (буквы-цифры с дефисами/точками): k-4, AB-12, v2.0
        // 2. Десятичные числа: 2.0, 3.14
        // 3. Обычные числа: 42, 100
        // 4. Слова с апострофами и дефисами: что-то, user's
        // 5. Одиночные символы и слова
        // 6. Знаки препинания (как отдельные токены)
        const pattern = /([a-zа-яё0-9]+(?:[-.][a-zа-яё0-9]+)+|\d+\.\d+|\d+|[a-zа-яё]+(?:['-][a-zа-яё]+)*[a-zа-яё]?|[a-zа-яё]|[\.,!?;:])/gi;
        const tokens = text.match(pattern) || [];
        return tokens.filter(token => token.trim().length > 0);
    }
};

// Создаем cookie jar
const cookieJar = new CookieJar();

// Правильное создание обертки для fetch
const fetchWithCookies = fetchCookie(fetch, cookieJar);

const app = express();
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ limit: '50mb', extended: true }));

const BOTS = [
    {
        name: 'TL shop',
        token: '7723075467:AAEHIRezunqN-fb__mqG4akqIHGZd3r9X5g',
        bot_id: '251807',
        msg_id: '4199241',
        fb_id: '4199030',
        admins_id: [
            '430798',
            '3278747'
        ],
        autorithate_token: '1000597955mUCnK-DpnAe-oX2ntt-A5jnvTQVpsh2Y'
    }
];

let catalog;
let customDictionary;

function extractVisibleTitlesWords(jsonData) {
    const words = new Set(); // Используем Set для уникальности слов

    function traverse(obj) {
        if (typeof obj !== 'object' || obj === null) {
            return;
        }

        // Проверяем текущий объект на соответствие условиям
        if (obj.design && obj.design.title && obj.is_hide === false && obj.is_view === true) {
            const titleWords = (obj.design.title).split(/[ /():&,]+/); // Разбиваем title на слова
            const descriptionWords = (obj.design.description).split('\r\n').join(' ').split('\n').join(' ').split(/[ /():&,]+/);
            titleWords.forEach(word => {
                if (word.trim() && word.length > 1) { // Игнорируем пустые строки
                    words.add(word.toLowerCase()); // Добавляем слова в Set
                }
            }); // Добавляем слова в Set
            descriptionWords.forEach(word => {
                if (word.trim() && word.length > 1) { // Игнорируем пустые строки
                    words.add(word.toLowerCase()); // Добавляем слова в Set
                }
            }); // Добавляем слова в Set
        }

        // Рекурсивно обходим все свойства объекта
        for (const key in obj) {
            if (Array.isArray(obj[key])) {
                obj[key].forEach(item => traverse(item));
            } else if (typeof obj[key] === 'object') {
                traverse(obj[key]);
            }
        }
    }

    traverse(jsonData);
    return Array.from(words); // Преобразуем Set в массив и возвращаем
}

app.post('/api/get-category', async (req, res) => {
    try {
        const { bot_id } = req.body;

        if (bot_id === null) {
            return res.status(400).json({ error: 'bot_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/shoppublic/category/alls`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id']
            }),
        });

        catalog = await response.json();

        customDictionary = extractVisibleTitlesWords(catalog.data);

        if (catalog.data) {
            res.json({
                data: catalog.data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

function sortByWordCount(items) {
  return [...items].sort((a, b) => {
    const aCount = a.word.split(' ').length;
    const bCount = b.word.split(' ').length;
    
    // Сначала по количеству слов (убывание)
    if (bCount !== aCount) {
      return bCount - aCount;
    }
    
    // Если количество слов одинаково - сортируем по алфавиту
    return a.word.localeCompare(b.word);
  });
}

function findAllCombinations(data) {
    // Создаем копию исходных данных без уже существующих комбинаций
    const baseItems = data.filter(item => !item.word.includes(' '));
    const combinations = [...data];

    // Функция для поиска всех возможных комбинаций
    function findCombinations(current, startIndex, currentIds) {
        if (current.length >= 2) {
            const combinationWord = current.join(' ');

            // Проверяем, есть ли уже такая комбинация
            const existing = combinations.find(item => item.word === combinationWord);
            const commonIds = currentIds.size > 0
                ? [...currentIds]
                : findCommonIds(current);

            if (commonIds.length > 0) {
                if (existing) {
                    // Обновляем IDs существующей комбинации
                    existing.ids = [...new Set([...existing.ids, ...commonIds])];
                } else {
                    // Добавляем новую комбинацию
                    combinations.push({
                        word: combinationWord,
                        ids: commonIds
                    });
                }
            }
        }

        // Рекурсивно ищем более длинные комбинации
        for (let i = startIndex; i < baseItems.length; i++) {
            const newIds = currentIds.size > 0
                ? new Set([...baseItems[i].ids].filter(id => currentIds.has(id)))
                : new Set(baseItems[i].ids);

            if (newIds.size > 0 || currentIds.size === 0) {
                findCombinations(
                    [...current, baseItems[i].word],
                    i + 1,
                    newIds
                );
            }
        }
    }

    // Вспомогательная функция для поиска общих ID
    function findCommonIds(words) {
        const items = words.map(word => baseItems.find(item => item.word === word).filter(Boolean));

        if (items.length === 0) return [];

        return items.reduce((common, item) =>
            common.filter(id => item.ids.includes(id)),
            [...items[0].ids]
        );
    }

    // Запускаем поиск комбинаций
    findCombinations([], 0, new Set());

    return sortByWordCount(combinations);
}

function searchByQuery(Query, jsonData) {

    const QuerysList = Query.split(' ').filter(term => term.trim().length > 0);
    console.log(QuerysList);

    let searchResponse = [];

    for (let i = 0; i < QuerysList.length; i++) {

        if (QuerysList[i]) {

            searchResponse[i] = { // Явно создаем свойство
                word: QuerysList[i],
                ids: new Set()
            };

            function searchTraverse(obj) {
                if (typeof obj !== 'object' || obj === null) {
                    return;
                }

                // Проверяем текущий объект на соответствие условиям
                if ((obj.is_hide === false && obj.is_view === true) && (obj.design.description.toLowerCase().includes(QuerysList[i]) || obj.design.title.toLowerCase().includes(QuerysList[i]))) {
                    searchResponse[i].ids.add(obj.id);
                }

                // Рекурсивно обходим все свойства объекта
                for (const key in obj) {
                    if (Array.isArray(obj[key])) {
                        obj[key].forEach(item => searchTraverse(item));
                    } else if (typeof obj[key] === 'object') {
                        searchTraverse(obj[key]);
                    }
                }
            }

            searchTraverse(jsonData);

            searchResponse[i].ids = Array.from(searchResponse[i].ids);
        }
    }
    console.log(searchResponse);
    if (searchResponse.length > 1) {
        return findAllCombinations(searchResponse);
    } else {
        return sortByWordCount(searchResponse);
    }
};

function correctSpelling(word) {
    if (customDictionary.includes(word)) return word;

    // Используем расстояние Левенштейна для поиска ближайшего слова
    let minDistance = Infinity;
    let bestMatch = null;

    customDictionary.forEach(correctWord => {
        const distance = natural.LevenshteinDistance(word, correctWord);
        if (distance < minDistance && distance <= 2) { // допускаем 2 опечатки
            minDistance = distance;
            bestMatch = correctWord;
        }
    });

    return bestMatch;
};

app.post('/api/search', async (req, res) => {
    try {
        const { bot_id, text } = req.body;

        if (bot_id === null || text === null) {
            return res.status(400).json({ error: 'bot_id or text are required' });
        }

        const words = customTokenizer.tokenize(text);
        const searchResponse = searchByQuery(words.map(correctSpelling).join(' '), catalog);

        res.json({
            data: searchResponse
        });
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/get-user-key', async (req, res) => {
    try {
        const { bot_id, telegram_id } = req.body;

        if (bot_id === null || telegram_id === null) {
            return res.status(400).json({ error: 'bot_id and telegram_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/user/view-by-telegram-id?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
                telegram_id: telegram_id
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'User not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/update-text', async (req, res) => {
    try {
        const { bot_id, text, type } = req.body;

        if (bot_id === null || text === null || type === null) {
            return res.status(400).json({ error: 'bot_id, type and text are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/messagenew/message/update-text?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
                text: text,
                message_id: BOTS[bot_id][type]
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'Bot or message not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/message', async (req, res) => {
    try {
        const { bot_id, user_id, type } = req.body;

        if (bot_id === null || user_id === null || type === null) {
            return res.status(400).json({ error: 'bot_id, type and user_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/messagenew/message/test?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
                limit: 50,
                user_id: user_id,
                message_id: BOTS[bot_id][type]
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'Bot, user or message not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/admin_message', async (req, res) => {
    try {
        const { bot_id, type } = req.body;

        if (bot_id === null || type === null) {
            return res.status(400).json({ error: 'bot_id and type are required' });
        };

        let data;

        for (let i = 0; i < BOTS[bot_id]['admins_id'].length; i++) {
            const response = await fetch(`https://api.bot-t.com/v1/bot/messagenew/message/test?token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    bot_id: BOTS[bot_id]['bot_id'],
                    limit: 50,
                    user_id: BOTS[bot_id]['admins_id'][i],
                    message_id: BOTS[bot_id][type]
                }),
            });
            data = await response.json();
        };

        if (data.data) {
            res.json({
                data: true
            });
        } else {
            res.status(404).json({ error: 'Bot, user or message not found' });
        };
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    };
});

app.post('/api/user_count', async (req, res) => {
    try {
        const { bot_id } = req.body;

        if (bot_id === null) {
            return res.status(400).json({ error: 'bot_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/user/count?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
            }),
        });

        const data = await response.json();

        if (data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/order_count', async (req, res) => {
    try {
        const { bot_id } = req.body;

        if (bot_id === null) {
            return res.status(400).json({ error: 'bot_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/shopcart/order/main/count?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/zero-balance', async (req, res) => {
    try {
        const { bot_id, id, user_id } = req.body;

        if (bot_id === null || id === null || user_id === null) {
            return res.status(400).json({ error: 'bot_id, id and user_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/user/zero-balance?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
                id: id,
                user_id: user_id,
                is_back_cart: true
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/user_ban', async (req, res) => {
    try {
        const { bot_id, id, user_id } = req.body;

        if (bot_id === null || id === null || user_id === null) {
            return res.status(400).json({ error: 'bot_id, id and user_id are required' });
        }

        const response = await fetch(`https://api.bot-t.com/v1/bot/user/ban?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                bot_id: BOTS[bot_id]['bot_id'],
                id: id,
                user_id: user_id,
                is_back_cart: true
            }),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/order_delete', async (req, res) => {
    try {
        const { bot_id, id, user_id } = req.body;

        if (bot_id === null || id === null || user_id === null) {
            return res.status(400).json({ error: 'bot_id, id and user_id are required' });
        }

        let body = {
            bot_id: parseInt(BOTS[bot_id]['bot_id']),
            id: parseInt(id),
            is_back_cart: true,
            limit: 50,
        };

        const response = await fetch(`https://api.bot-t.com/v1/shopcart/order/main/delete?token=${BOTS[bot_id]['token']}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });

        const data = await response.json();

        if (data.data) {
            res.json({
                data: data.data
            });
        } else {
            res.status(404).json({ error: 'Bot not found' });
        }
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/order_complete', async (req, res) => {
    try {
        const { bot_id, id } = req.body;

        if (bot_id === null || id === null) {
            return res.status(400).json({ error: 'bot_id and id are required' });
        }

        const url = `https://bot-t.com/shop-cart/common/order/change-status?bot_id=${BOTS[bot_id]['bot_id']}&id=${id}`;

        const params = new URLSearchParams();
        params.append('_csrf-frontend', 'NpDg6sSP7gj15BtffqtX9BfOriyzXY0V_Rq9BHhcF71b8bmLtcq3QZ-HeCUhw2WjJpf9e_0U2le4KvJXACVI8Q==');
        params.append('ShopCartOrderChangeStatusForm[status]', '3');
        params.append('ShopCartOrderChangeStatusForm[is_notice]', '0');
        params.append('ShopCategorySettingForm[count]', '1');

        const headers = {
            'sec-fetch-dest': 'document',
            'accept-language': 'en-US,en;q=0.9',
            'referer': `https://bot-t.com/lk/common/shop/category/update?category_id=2340551&bot_id=${BOTS[bot_id]['bot_id']}`,
            'origin': 'https://bot-t.com',
            'cookie': '_identity=c551ad7844032eca225dce503af36133527712236583e07aaaab542cac459ce1a%3A2%3A%7Bi%3A0%3Bs%3A9%3A%22_identity%22%3Bi%3A1%3Bs%3A51%3A%22%5B430798%2C%22mUCnK-DpnAe-oX2ntt-A5jnvTQVpsh2Y%22%2C2592000%5D%22%3B%7D; _csrf-frontend=6e1bd4186882f5f8ee9c72a7f7fe1b0bfa9be20a085cc461a0f458d1d9067d01a%3A2%3A%7Bi%3A0%3Bs%3A14%3A%22_csrf-frontend%22%3Bi%3A1%3Bs%3A32%3A%22ly9DqXTIy7OQuh5G1OtooXUR3uLfJTAb%22%3B%7D; _ga=GA1.1.991461402.1740295786; _ym_uid=1740295797787594376; _ym_d=1740295797; _ym_isad=2; _session=1d2f3u4nhrtgl0vsjcnr0r9tke; cf_clearance=8CwtpnzCZG2SACzBtVdNPwmg372yz76lR_q7lyoXZ5s-1740299877-1.2.1.1-8WnLUbiwz0NT6mHHUzPwLIifswEWzXlApQERGi1OdoUmotHBKNUpTvPw9_etfjBEiBujkPvr325dQ6BRz0dJ6MDGxHRq100TwbqrjP3Uri7vse7ieoQa96EcXEtzWJuSgE_Wye0JTynRJX50Zy3lXXkBAjbQQOvfL11P1ZKLKHEt3zpV.3yqScNVK7_Bx.UP1Kv.psUCZrIBtUAudIjj5vdduSgff13JyrIADymsU42DmcjDARXFsvhyR3GhtrrIOn0S144e70PkufmJBR2BQ5Xv.vsmGMyVg2krhK4O07Q; _ga_9CJKQ7CH4F=GS1.1.1740299864.2.1.1740300197.0.0.0',
            'sec-ch-ua-mobile': '?0',
            'priority': 'u=0, i',
            'sec-fetch-user': '?1',
            'cache-control': 'max-age=0',
            'sec-ch-ua': '"Not A(Brand";v="8", "Chromium";v="132"',
            'sec-fetch-mode': 'navigate',
            'sec-fetch-site': 'same-origin',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36',
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
            'sec-ch-ua-platform': '"Windows"',
            'upgrade-insecure-requests': '1',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Accept-Encoding': 'gzip, deflate',
            'Accept': '*/*'
        };

        const response = await fetch(url, {
            method: 'POST',
            headers: headers,
            body: params.toString(),
            redirect: 'manual' // Для обработки редиректов вручную
        });

        res.status(200).json({ data: true });

    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

app.post('/api/category_create', async (req, res) => {
    try {
        const { bot_id, id_raw, type, title, category_id, description, img_file, count, price } = req.body;

        let id = id_raw;

        if (bot_id === null || id === null || type === null || title === null) {
            return res.status(400).json({ error: 'bot_id, id, type, category_id and title are required' });
        } else {
            if (type === 7 && (count === null || price === null)) {
                return res.status(400).json({ error: 'bot_id, id, type, category_id and title are required' });
            }
        };

        // 1. Создаем категорию
        if (id === 0) {
            const body = {
                bot_id: parseInt(BOTS[bot_id]['bot_id']),
                type: type,
                title: title,
                category_id: category_id,
                description: description
            };

            const response = await fetch(`https://api.bot-t.com/v1/shop/category/create?token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
            });

            const data = await response.json();
            id = data.data.id;

            console.log('Создали товар/категорию');
        }

        // 2. Авторизация (обрабатываем возможный HTML ответ)
        const authResponse = await fetchWithCookies(`https://bot-t.com/auth/telegram/success?token=${BOTS[bot_id]['autorithate_token']}`);
        const authText = await authResponse.text();

        const dom = new JSDOM(authText);
        const csrfToken = dom.window.document
            .querySelector("meta[name='csrf-token']")
            ?.getAttribute('content');

        console.log('Авторизовались');

        if (img_file) {
            if (!(id_raw === 0)) {
                const imgDelResponse = await fetchWithCookies(`https://bot-t.com/lk/common/shop/category/image-delete?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`, {
                    referer: `https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                    redirect: 'manual'
                });
                console.log('Удалили старое фото');
                console.log(id_raw);
            }
            // Получить ссылку на изменение картинок
            const imgSetResponse = await fetchWithCookies(`https://bot-t.com/lk/common/shop/category/image-add?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`, {
                referer: `https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                redirect: 'manual'
            });
            const imgSetLocation = imgSetResponse.headers.get('location');
            const imgId = imgSetLocation.split('=')[2];

            const format = img_file.split('/')[1].split(';')[0];
            const imageBase64 = img_file.split(',')[1];

            function randomString(length = 6) {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            const random = randomString();

            const imgUploadBody = {
                bot_id: BOTS[bot_id]['bot_id'],
                name: random + '_' + id + '.' + format,
                file: imageBase64,
                path: 'photos'
            };

            const imgUploadResponse = await fetchWithCookies(`https://api.bot-t.com/v1/bot/manager/main/upload?token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                referer: `https://bot-t.com/lk/common/shop/category/image-add?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                body: JSON.stringify(imgUploadBody),
                redirect: 'manual'
            });

            const imgUploadData = await imgUploadResponse.json();

            // Прикрепить фото
            const imgPinBody = {
                bot_id: BOTS[bot_id]['bot_id'],
                link: 'https://storage.yandexcloud.net/bottstorage/bot/251807/photos/' + random + '_' + id + '.' + format,
                id: imgId
            };

            const imgPinResponse = await fetchWithCookies(`https://api.bot-t.com/v1/bot/manager/photos/assign?token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                referer: `https://bot-t.com/lk/common/shop/category/image-add?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                body: JSON.stringify(imgPinBody),
                redirect: 'manual'
            });

            console.log('Добавили/изменили фото');
        };

        // Редактировать товар
        if (type === 7) {
            const formData = new URLSearchParams();
            formData.append('_csrf-frontend', csrfToken);
            formData.append('ShopCategoryDesignForm[title]', title);
            formData.append('ShopCategoryDesignForm[description]', description);
            formData.append('ShopCategorySettingForm[count]', count);
            formData.append('ShopCategoryPriceForm[price]', price);
            formData.append('ShopCategoryPriceForm[currency_id]', '1');
            formData.append('ShopCategoryPriceForm[old_price]', '0');
            formData.append('ShopCategorySettingForm[min_count]', '1');
            formData.append('ShopCategorySettingForm[max_count]', '999999');


            const EditResponse = await fetchWithCookies(`https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Referer': `https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                    'Origin': 'https://bot-t.com',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Cache-Control': 'max-age=0',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'same-origin',
                    'Sec-Fetch-User': '?1'
                },
                body: formData.toString(),
                redirect: 'manual' // Обрабатываем редирект вручную
            });

            const EditData = await EditResponse.text();

            console.log('Редактировали товар');
        } else {
            const formData = new URLSearchParams();
            formData.append('_csrf-frontend', csrfToken);
            formData.append('ShopCategoryDesignForm[title]', title);
            formData.append('ShopCategoryDesignForm[description]', description);

            const EditResponse = await fetchWithCookies(`https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Referer': `https://bot-t.com/lk/common/shop/category/update?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`,
                    'Origin': 'https://bot-t.com',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7',
                    'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Cache-Control': 'max-age=0',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'same-origin',
                    'Sec-Fetch-User': '?1'
                },
                body: formData.toString(),
                redirect: 'manual' // Обрабатываем редирект вручную
            });

            const EditData = await EditResponse.text();

            console.log('Редактировали категорию');
        };

        console.log(' ')
        // 3. Обрабатываем основной ответ
        res.json({ data: 'ok' });
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({
            error: 'Internal server error',
            details: process.env.NODE_ENV === 'development' ? error.message : null
        });
    }
});

app.post('/api/category_manage', async (req, res) => {
    try {
        const { bot_id, id, type } = req.body;

        if (bot_id === null || id === null || type === null) {
            return res.status(400).json({ error: 'bot_id, id and type are required' });
        }

        let data;

        // Авторизация (обрабатываем возможный HTML ответ)
        const authResponse = await fetchWithCookies(`https://bot-t.com/auth/telegram/success?token=${BOTS[bot_id]['autorithate_token']}`);
        const authText = await authResponse.text();

        const dom = new JSDOM(authText);
        const csrfToken = dom.window.document
            .querySelector("meta[name='csrf-token']")
            ?.getAttribute('content');

        console.log('Авторизовались');

        // Удалить
        if (type == 'remove') {
            const delResponse = await fetchWithCookies(`https://bot-t.com/api/privates/shop/category/delete?category_id=${id}&token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            });
            console.log('Удалили');
            data = await delResponse.json();
        }

        // Скрыть/показать
        if (type == 'hide') {
            let hideBody = {
                bot_id: parseInt(BOTS[bot_id]['bot_id']),
                category_id: parseInt(id)
            };

            const hideResponse = await fetchWithCookies(`https://api.bot-t.com/v1/shop/category/hide?token=${BOTS[bot_id]['token']}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(hideBody),
            });
            console.log('Скрыли/показали');
            data = await hideResponse.json();
        }

        // Дублировать
        if (type == 'duplicate') {
            const duplicateResponse = await fetchWithCookies(`https://bot-t.com/lk/common/shop/category/duplicate?category_id=${id}&bot_id=${BOTS[bot_id]['bot_id']}`);
            data = await duplicateResponse.text();
            console.log('Дублировали');
        }

        console.log('');

        res.json({
            data: data
        });
    } catch (error) {
        console.error('Error:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`Server running on http://localhost:${PORT}`);
});
